# Python Statements - yield

[[Python Statements]] [[Python Keywords]] [[Python Functions]]

---

- [ ] [todo](https://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do)
- [ ] combine with [[Python Functions]]

* 在[[Python Statements - def|函数定义]]中, 除了可以使用 [[Python Statements - return|return]] 语句返回一个**静态对象**外, 还可以用 *yield* 语句返回一个[[Python Types - Iterable|可迭代]]生成器 [[generator]], 这个 generator 其实就是函数本身, 即每次调用该 generator 的时候, 就会运行
* 因此带有 *yield* 语句的函数不再是一个普通函数, Python 解释器会将其视为一个 [[generator]] function
* 基本语法:

    ```py
    def fun():
        block1
        yield expr
        block2
    ```

    * 每次调用该函数时, 程序执行函数内部的代码只会执行到 *yield* 语句，返回此次**迭代** *expr* 的结果
    * **下次迭代**(调用)时, 代码从上次迭代时的 *yield* 的下一条语句**继续**执行, 而**函数的本地变量看起来和上次中断执行前是完全一样的**, 于是函数继续执行, 直到再次遇到 *yield*
* *yield* 使得函数可以**惰性求值**, 适用于将产生大量数据的函数变为 generator

## Examples

[Fibonacci 数列生成器](https://www.runoob.com/w3cnote/python-yield-used-analysis.html)

也可以手动调用 fab(5) 的 next() 方法（因为 fab(5) 是一个 generator 对象，该对象具有 next() 方法），这样我们就可以更清楚地看到 fab 的执行流程：

[//begin]: # "Autogenerated link references for markdown compatibility"
[Python Statements]: Python Statements "Python Statements"
[Python Keywords]: Python Keywords "Python Keywords"
[Python Functions]: Python Functions "Python Functions"
[Python Functions]: Python Functions "Python Functions"
[//end]: # "Autogenerated link references"