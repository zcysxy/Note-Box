---
alias: [lambda 表达式]
---

# Python Lambda Function

[[Python Functions]] | [[Python Keywords]]

---

## Basics

* lambda 表达式可以用来声明匿名函数 anonymous function, 即**没有函数名字**的**临时使用**的小函数
* 只可以**包含一个[[Python Expressions|表达式]]**, 不允许包含其他复杂的语句, 但可以有任意多个参数且可以调用其他函数
    * 一个表达式不是指只能返回一个元素, 如列表推导式可以返回一个列表, 更一般的, 可以把**表达式序列**看成一个表达式
        * 表达式序列指: `[exp1,exp2,...]`, `(exp1,exp2)` 等, 则它们返回结果列表, 结果元组等
* 该表达式的计算结果为函数的返回值
* 语法:

    ```py
    f = lambda x1, x2, ...: expression
    ```

    * *f* 为 "值" 为定义的匿名函数的变量, *xi* 为参数, 函数返回 *expression* 的结果
    * 若 *expression* 无需参数则可省略 *xi* 部分
        * 如 `lambda: time.strftime('%Y/%m/%d')`
* lambda 函数[[Python Statements - def#参数 Attributes|参数设置]]方法, [[Python Functions#Calling a Function|函数调用]]和参数传递方法跟其他函数一致

## Examples

1. Arithmetic expression

    ```py
    import math
    f = lambda x,y: (math.sin(x)+math.cos(y))/2
    ```

2. [[Python Conditional Expressions|Conditional expression]]

    ```py
    f = lambda x: x if x>0 else -x
    ```

3. [[List Comprehension]]

    ```py
    f = lambda x: [each + 10 for each in x]
    ```

4. 查表法函数

如要实现函数

$$y = \begin{cases}
x, &-10 \le x < 0\\
x^2, &0\le x\le10\\
10, &10< x\le20\\
0.5x + 20, &20< x<40\\
\end{cases} $$

```py
f = [
    lambda x: x**2,\
    lambda x: 10 if x != 10 else x**2,\
    lambda x: 0.5*x + 20 if x != 20 else 10,\
    lambda x: 0.5*x + 20,\
    lambda x: x if x != 40 else 0.5*x +20
]

print(f[x//10](x))
```

## 匿名性

除了将 lambda 函数 "赋值" 给一个变量, 使得函数继承了变量的名字外, lambda 本身无需命名, 见下例:

```py
fun_list = [lambda x: x**2, lambda x: x**3, lambda x: x**4]
for i in range(len(fun_list)):
    print(fun_list[i](2.5))
```

```py
fun_dict = {'square': lambda x: x**2, 'cubic': lambda x: x**3, 'biquadratic': lambda x: x**4 }
for key in fun_dict:
    print(fun_dict[key](2.5))
```

于是类似于[[Python Types|数据类型]], 也可将函数看作一个类型 (class function), 而用 [[Python Statements - def|def]] 定义函数只是像将一种数据类型赋值给一个变量一样, 将一个函数 "赋值" 给一个函数名.

## 利用 lambda 表达式排序

函数 [[Python Functions - sorted|sorted]] 和[[Python Types - List#list sort|列表方法 .sort()]] 都有可选参数 *key*, *key* 本质上需要传递的是一列或多列可排序的序列, 这些序列中的每个元素都对应着被排序列表中的一个元素, 则函数/方法返回按照传递的序列的顺序关系排列的原列表.

常见的 *key* 有两种, 一种是利用 `operator.itemgetter()` 传递现成的对应序列, 如字典的值序列, 多维列表的某下标一致的一列等; 另一种就是利用函数生成每个元素对应值, 形成一个对应序列. 函数自然可以是通过 [[Python Statements - def|def]] 定义的一般函数, 但如果只是为了临时排序, 通常直接在行内定义 lambda 函数实现排序规则.

例如按数字各位数之和从小到大排序:

```py
l = [29, 71, 255, 68, 54, 148, 37, 90]
l.sort(key = lambda x: sum([eval(i) for i in str(x)]))
```

随机排列:

```py
import random
l = [29, 71, 255, 68, 54, 148, 37, 90]
length = len(l)
#！ 注意这里必须先将 length 固定, 因为 .sort() 方法过程中列表长度会变
l.sort(key = lambda x: random.randint(1,length))
```

先按姓名最后一个字母排序, 再按姓名倒数第二个字母排序:

```py
names = ['Mary', 'Kate', 'Tom', 'Kevin', 'Laura', 'Josh', 'Emma']
names.sort(key = lambda x: (x[-1], x[-2]))
print(names)
```

!! 注意, 用于排序的 lambda 函数的返回值必须是可排序的.

[//begin]: # "Autogenerated link references for markdown compatibility"
[Python Functions]: Python Functions "Python Functions"
[Python Keywords]: Python Keywords "Python Keywords"
[//end]: # "Autogenerated link references"