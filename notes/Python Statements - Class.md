# Python Statements - Class

[[Python Statements]] | [[Python Classes]] | [[Python Keywords]]

---

```python
class ClassName:
    <statement-1>
    ...
    <statement-N>
```

## Self Parameter

[[Python Classes]] 已经谈到实例 instance 的意义, 它不仅在访问类时要用到, 类本身的定义中也要用到各种实例参数和方法. 而参数 `self` 就表示类自身的一个**实例**, 在定义类时需要调用自己的数据成员或成员方法时可用 `self` 为前缀调用, 同时在定义实例函数时也需以 `self` 作为第一个形参.

!! "self" 是惯例参数名, 但也可以用其他的名字, 其他规则不变

## __init__() Function

所有类都有一个**构造函数**: `__init__()`, 它在该类初始化时执行.

[[Python Classes]] 的数据成员 attribute 又可以分为两类:

* **实例属性**: 在构造函数 `__init__()` 中定义的变量
    * 定义时需要以 `self` 为前缀
    * 在类定义中访问实例属性需要加 `self` 前缀
    * 在类定义外访问实例属性只能通过实例/对象访问
* **类属性**: 类定义中所有方法之外的数据成员
    * 定义时无需以 `self` 为前缀
    * 在类定义中访问实例属性无需 `self` 前缀
    * 在类定义外访问实例属性除了可以通过实例/对象访问之外, 还可以直接通过类来访问
* 有同名实例属性和类属性时, 优先访问实例属性

```python
class Cla:
    x = 10 # 类属性
    def __init__(self):
        self.y = 100 # 实例属性

cla1 = Cla() # 实例化
print(cla1.y, cla1.x) # 通过对象访问 
print(Cla.x) # 通过类访问, 
# print(Cla.y) 报错
```

跟一般函数一样构造函数可以有多个输入参数 `__init__(self, a1, ..., an)`. 而参数传递在调用类时完成 `Class(x1,...,xn)`

```python
class Cla():
    def __init__(self,a):
        self.a = a

cla1 = Cla(1) # 传递 a = 1 
print(cla1.a, Cla(1).a)
```

## Methods

类定义中的方法大致可分为五类:

* 公有方法
* 私有方法
* 抽象方法
* 静态方法
* 类方法

其中公有方法, 私有方法, 抽象方法都属于**实例方法**, 需以 `self` 为第一个参数, 代表当前对象. 实例方法定义中要访问类中其他成员时需要加 `self` 前缀. 公有方法和私有方法的区别见 [Private Members & Public Members](#private-members--public-members)

抽象方法, 静态方法, 类方法定义前都需要用[[Python Decorator|修饰器]]预先声明.

静态方法和类方法是非实例方法, 它们可以看作在类定义中与该类无关地两种方法, 因此它们内外都无需传递 `self` 参数.

其他的类定义方法与 [[Python Functions]] 一致.

### Magic Methods

Python 中有很多特殊方法 magic methods, 它们是**类**中预先定义好的并且已经被决定了在何时何处被调用. 它们统一的名字形式是 `__name__`, 如[`__init__`](#init-function). 又比如计算 `1 + 1` 时, python 就调用了 int 类中的 `__add__` 方法.

!! 注意特殊方法不是私有方法

虽然特殊方法都是已经有定义的, 但是我们可以在类定义中重构它们来实现自定义性质. 常用的特殊方法见 [[Python Magic Methods]].

## Private Members & Public Members

与 [[Python Functions]] 的作用域类似, 类定义中也分私有成员和公有成员, 通过成员名区分:

* `_name` 保护成员, 或非公有成员. 只有类定义中对象和**子类对象**可以访问, 在类定义外**不建议**访问
    * 保护成员不能通过 `from module import *` 导入
* `__name` 私有成员. 只有在类定义中对象能访问, **[子类对象](#inheritance)**和定义外都不能访问
    * 但在在定义外可通过 `obj._Class__name` 语法来访问私有成员
    * 似乎可以用 `Class.__privateMemeber = x` 来增添类的私有成员, 但其实这不是私有成员, 因为在类内部, 私有成员是以 `_Class__PrivateMember` 的名字储存的

注意类中的私有与公有不是很严格, 它更多的是一种规范.

## Property Decorator

通过定义私有成员可以拒绝外部对它们的访问, 但有时只需要限制部分权限即可, 则可利用 [[Python Decorator]] *property*.

* 仅可读

```python
class Test:
    def __init__(self, value):
        self.__value = value # 私有数据成员
    
    @property               # 修饰器, 定义属性, 提供对私有数据成员的访问, 限制函数 value 不可修改
    def value(self):
        return self.__value  # 只读属性, 无法修改和删除

t = Test(5)
print(t.value) # 打印结果 5
# t.value = 5 # 报错 AttributeError: can't set attribute
```

* 可读, 可修改, 不可删除

```python
class Test:
    def __init__(self, value):
        self.__value = value
    
    def __get(self):
        return self.__value

    def __set(self, v):
        self.__value = v

    value = property(__get, __set) # 提供对私有数据的读取和修改方法

    def show(self):
        print(self.__value)

t = Test(3)
print(t.value) # 打印结果 3
t.value = 5
t.show() # 打印结果 5
```

## Inheritance

继承是为代码复用和设计复用而设计的, 是面向对象程序设计的重要特性之一. 当我们设计一个新类时, 若继承一个已有的设计良好的类然后进行二次开发, 可以大幅度减少开发工作量.

在继承关系中, 已有的, 设计好的类称为**父类**或**基类** base class, 新设计的类称为**子类**或**派生类** derived class. 派生类可以继承父类的**公有成员**, 但是不能继承其**私有成员**. 如果需要在派生类中调用基类的方法, 可以使用内置函数 `super(DerivedClass, self)` 或者通过 `BaseClass.method()` 的方式来实现这一目的.

!! 若要使用 *super* 函数, 基类需继承自类 `object`

若派生类和基类有同名成员, 则优先调用派生类成员. 同时 Python 支持多继承, 如果父类中有相同的方法名, 而在子类中使用时没有指定父类名, 则解释器将**从左向右**按顺序进行搜索.

```python
class DerivedClass(BaseClass1,...,BaseClassn):
```

另外, [[Python Functions - isinstance|isinstance]] 函数判断派生类实例属于基类为 *True*, 反之为 *False*.

## Examples

```python
class A():
    def __init__(self):
        self.__private()
        self.public()
    def __private(self):
        print('__private() method of A')
    def public(self):
        print('public() method of A')
class B(A):
    def __private(self):
        print('__private() method of B')
    def public(self):
        print('public() method of B')

b = B()
# output:
# __private() method of A
# public() method of B
```

上例比较特殊, 派生类 B 继承了 A 的 `__init__()` 函数, 但这个函数又是定义在 A 中的, 它无法访问 B 的私有函数, 因此得到比较特殊的打印结果.

[//begin]: # "Autogenerated link references for markdown compatibility"
[Python Statements]: Python Statements "Python Statements"
[Python Classes]: Python Classes "Python Classes"
[Python Keywords]: Python Keywords "Python Keywords"
[Python Classes]: Python Classes "Python Classes"
[Python Classes]: Python Classes "Python Classes"
[Python Functions]: Python Functions "Python Functions"
[Python Magic Methods]: Python Magic Methods "Python Magic Methods"
[Python Functions]: Python Functions "Python Functions"
[//end]: # "Autogenerated link references"