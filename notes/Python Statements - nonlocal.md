# Python Statements - nonlocal

[[Python Statements]] [[Python Keywords]]

---

* 在**嵌套函数**的[[Python Statements - def|定义]]中, 利用 *nonlocal* 语句声明一个**内层**函数中的对象不是[[Python Scope#Local|局部]]对象, 而是[[Python Scope#Enclosing|外层]]对象
* *nonlocal* 语句不能取代 [[Python Statements - global|global]] 语句将对象声明为[[Python Scope#Global|全局]]对象
    * 如果声明对象的外一层就是全局作用域时, 只能用 [[Python Statements - global|global]] 语句声明, *nonlocal* 会报错
* 在多重嵌套中, *nonlocal* 只会上溯一层; 而如果上一层没有, 会继续上溯

    ```py
    def myfunc1():
        x, y, z = 1, 1, 1

        def myfunc2():
            nonlocal y          #1
            x, y= 2, 2
            
            def myfunc3():
                nonlocal x      #2
                nonlocal z      #3
                x, y, z = 3, 3, 3
                return x, y, z
            
            myfunc3()
            return x, y, z

        print(myfunc2())
        return x, y, z

    print(myfunc1())
    ```

    以上代码的输出为 `(3, 2, 3)` 和 `(1, 2, 3)`
    * `print(myfunc2())` 输出为 `(3, 2, 3)` 就是因为 *#2* 和 *#3* 声明了 %x%, %z% 为外层对象后, 改变了它们的值
        * 但是因为 *#3* 的外一层没有 %z%, 故其找到的其实是 *myfunc1* 下的 %z%
    * `print(myfunc1())` 输出为 `(1, 2, 3)` 就是因为 *#1* 和 *#3* 声明了 %y% 和 %z% 为外层对象后, 改变了它们的值
        * 虽然 *#2* 也声明了 %x% 为外层对象, 但因为其只上溯一层就找了 *myfunc2* 下的 %x%, 故改变的是它的值, 并不会影响 *myfunc1* 下的 %x%

[//begin]: # "Autogenerated link references for markdown compatibility"
[Python Statements]: Python Statements "Python Statements"
[Python Keywords]: Python Keywords "Python Keywords"
[//end]: # "Autogenerated link references"